priority -50
# imports
################################################################
snippet trans "The translation module" b
from django.utils.translation import ugettext_lazy as _
endsnippet

snippet iurl "Import url boilerplate" b
from django.conf.urls import url

from . import views
endsnippet

snippet uurl "url function call for urls.py" b
url(regex=r'^${1:}$',
    view=views.${2:Model}${3:-S-}View.as_view(),
    name='${3/.+/\L$0\E/g}'),
endsnippet

snippet idgra "graphene imports for django" b
from graphql_relay.node.node import from_global_id
from graphene_django.types import DjangoObjectType
from graphene import relay
import graphene
endsnippet

# Test Snippets
################################################################
snippet tschema "Test a graphene schema" b
from ..schema import Query

import graphene


class ${1:Test}Schema(Query, graphene.ObjectType):
    """Schema for testing"""
    pass

test_schema = graphene.Schema(query=${2:$1}Schema)
endsnippet

snippet tgq "Test a basic query on a schema" b
def test_${1:base}(self):
    query = '''
        query {
            ${1/.+/$0/g:base} (uuid: "%s") {
            ${2:name}
            uuid
            }
        }
        ''' % self.user1.uuid

    expected = {'${1/.+/$0/g:base}': {
            '$2': '%s' % self.${1/.+/$0/g:base}1.$2 ,
            'uuid': '%s' % self.${1/.+/$0/g:base}1.uuid
            }}
    result = test_schema.execute(query)
    /*- TODO: switch to variable_values for easier query creation <09-08-17,djapo> -*/
    # result = test_schema.execute(query, variable_values=?)

    assert not result.errors
    assert result.data == expected
endsnippet

# Graphene
################################################################
snippet gboiler "graphene boilerplate" b
class ${1/.+/$0/g:Model}Type(DjangoObjectType):

    """Query API def for $1"""

    class Meta:
        model = $1
        only_fields = (${2:fields list})

        interfaces = (relay.Node, )

    def resolve_id(self, args, context, info):
        return str(self.${3:uuid})

    @classmethod
    def get_node(cls, id, context, info):
        return context.dataloaders.${1/.+/\L$0\E/g:model}.load(id)

    @classmethod
    def get_queryset(cls):
        qs = cls._meta.model.objects.all().only(*cls._meta.only_fields)
        return qs


class ${1/.+/$0/g:model}Query(graphene.AbstractType):
    ${1/.+/\L$0\E/g:model} = graphene.Field($1Type, $3=graphene.String())
    all_${1/.+/\L$0\E/g:model}s = graphene.List($1Type)

    def resolve_${1/.+/\L$0\E/g:model}(self, input, context, info):
        qs = $1Type.get_queryset()
        $3 = input.get('$3')
        return qs.get($3=$3)

    def resolve_all_${1/.+/\L$0\E/g:model}s(self, input, context, info):
        return $1Type.get_queryset()


class Create$1(graphene.ClientIDMutation):
    ${1/.+/\L$0\E/g:model} = graphene.Field($1Type)
    form_messages = graphene.String()
    status = graphene.Int()

    class Input:
        name = graphene.String()

    @classmethod
    def mutate_and_get_payload(root, input, context, info):
        # Remember to import correct Form
        mform = $1Form(name=input.get('name'))
        if mform.is_valid():
            try:
                ${1/.+/\L$0\E/g:model}inst = mform.save()
                return Create$1(${1/.+/\L$0\E/g:model}=${1/.+/\L$0\E/g:model}inst, form_messages=None)
            except Exception as valerror:
                return Create$1(${1/.+/\L$0\E/g:model}=None, form_messages='An internal error occurred.')
        return Create$1(${1/.+/\L$0\E/g:model}=None, form_messages=mform.errors)


class Update$1(graphene.ClientIDMutation):
    ${1/.+/\L$0\E/g:model} = graphene.Field($1Type)
    form_messages = graphene.String()
    status = graphene.Int()

    class Input:
        name = graphene.String()
        $3 = graphene.String()

    @classmethod
    def mutate_and_get_payload(root, input, context, info):
        inst = $1.objects.get($3 =input.pop('$3 '))
        # Remember to import correct Form
        mform = $1Form(input, instance=inst)
        if mform.is_valid():
            try:
                ${1/.+/\L$0\E/g:model}inst = mform.save()
                return Update$1(${1/.+/\L$0\E/g:model}=${1/.+/\L$0\E/g:model}inst, form_messages=None)
            except Exception as valerror:
                return Update$1(${1/.+/\L$0\E/g:model}=None, form_messages='An internal error occurred.')
        return Update$1(${1/.+/\L$0\E/g:model}=None, form_messages=mform.errors)


class Delete$1(graphene.ClientIDMutation):
    ${1/.+/\L$0\E/g:model} = graphene.Field($1Type)
    form_messages = graphene.String()

    class Input:
        name = graphene.String()
        id = graphene.ID()

    @classmethod
    def mutate_and_get_payload(root, input, context, info):
        ${1/.+/\L$0\E/g:model}inst = $1.objects.get(pk=input.get('id'))
        ${1/.+/\L$0\E/g:model}inst.delete()
        return Delete$1(${1/.+/\L$0\E/g:model}=None, form_messages=None)


class $1Mutation(graphene.AbstractType):
    create_${1/.+/\L$0\E/g:model} = Create$1.Field()
    update_${1/.+/\L$0\E/g:model} = Update$1.Field()
    delete_${1/.+/\L$0\E/g:model} = Delete$1.Field()


class $1Loader(DataLoader):
    def batch_load_fn(self, keys):
        # Here we return a promise that will result on the
        # corresponding $1 for each key in keys
        def process_res(res):
            res_by_$3 = {str(row.$3): row for row in res}
            return [res_by_$3.get(key, None) for key in keys]
        return Promise.resolve($1Type.get_queryset().order_by().filter($3__in=keys)).\
            then(lambda res: res if len(res) is len(keys) else process_res(res))
endsnippet
